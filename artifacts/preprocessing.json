{
  "Binarizer": {
    "name": "sklearn.preprocessing._data.Binarizer",
    "common_name": "Binarizer",
    "description": "Binarize data (set feature values to 0 or 1) according to a threshold. Values greater than the threshold map to 1, while values less than or equal to the threshold map to 0. With the default threshold of 0, only positive values map to 1.  Binarization is a common operation on text count data where the analyst can decide to only consider the presence or absence of a feature rather than a quantified number of occurrences for instance.  It can also be used as a pre-processing step for estimators that consider boolean random variables (e.g. modelled using the Bernoulli distribution in a Bayesian setting).  Read more in the :ref:`User Guide <preprocessing_binarization>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "threshold",
        "init_args": {
          "semantic_types": [
            "threshold"
          ],
          "_structural_type": "float",
          "default": 0.0,
          "description": "Feature values below or equal to this are replaced by 0, above it by 1. Threshold may not be less than 0 for operations on sparse matrices."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "set to False to perform inplace binarization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix)."
        }
      }
    ],
    "Params": []
  },
  "FunctionTransformer": {
    "name": "sklearn.preprocessing._function_transformer.FunctionTransformer",
    "common_name": "FunctionTransformer",
    "description": "Constructs a transformer from an arbitrary callable. A FunctionTransformer forwards its X (and optionally y) arguments to a user-defined function or function object and returns the result of this function. This is useful for stateless transformations such as taking the log of frequencies, doing custom scaling, etc.  Note: If a lambda is used as the function, then the resulting transformer will not be pickleable.  .. versionadded:: 0.17  Read more in the :ref:`User Guide <function_transformer>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "func",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "func"
          ],
          "default": "func__None",
          "description": "The callable to use for the transformation. This will be passed the same arguments as transform, with args and kwargs forwarded. If func is None, then func will be the identity function."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "func__Callable",
            "init_args": {
              "semantic_types": [
                "func"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "func__None",
            "init_args": {
              "semantic_types": [
                "func"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "inverse_func",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "inverse_func"
          ],
          "default": "inverse_func__None",
          "description": "The callable to use for the inverse transformation. This will be passed the same arguments as inverse transform, with args and kwargs forwarded. If inverse_func is None, then inverse_func will be the identity function."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "inverse_func__Callable",
            "init_args": {
              "semantic_types": [
                "inverse_func"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "inverse_func__None",
            "init_args": {
              "semantic_types": [
                "inverse_func"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "validate",
        "init_args": {
          "semantic_types": [
            "validate"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Indicate that the input X array should be checked before calling ``func``. The possibilities are:  - If False, there is no input validation. - If True, then X will be converted to a 2-dimensional NumPy array or   sparse matrix. If the conversion is not possible an exception is   raised.  .. versionchanged:: 0.22    The default of ``validate`` changed from True to False."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "accept_sparse",
        "init_args": {
          "semantic_types": [
            "accept_sparse"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Indicate that func accepts a sparse matrix as input. If validate is False, this has no effect. Otherwise, if accept_sparse is false, sparse matrix inputs will cause an exception to be raised."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "check_inverse",
        "init_args": {
          "semantic_types": [
            "check_inverse"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Whether to check that or ``func`` followed by ``inverse_func`` leads to the original inputs. It can be used for a sanity check, raising a warning when the condition is not fulfilled.  .. versionadded:: 0.20"
        }
      },
      {
        "name": "kw_args",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "kw_args"
          ],
          "default": "kw_args__None",
          "description": "Dictionary of additional keyword arguments to pass to func.  .. versionadded:: 0.18"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "kw_args__dict",
            "init_args": {
              "semantic_types": [
                "kw_args"
              ],
              "_structural_type": "dict"
            }
          },
          {
            "type": "Constant",
            "name": "kw_args__None",
            "init_args": {
              "semantic_types": [
                "kw_args"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "inv_kw_args",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "inv_kw_args"
          ],
          "default": "inv_kw_args__None",
          "description": "Dictionary of additional keyword arguments to pass to inverse_func.  .. versionadded:: 0.18"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "inv_kw_args__dict",
            "init_args": {
              "semantic_types": [
                "inv_kw_args"
              ],
              "_structural_type": "dict"
            }
          },
          {
            "type": "Constant",
            "name": "inv_kw_args__None",
            "init_args": {
              "semantic_types": [
                "inv_kw_args"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      }
    ],
    "Params": []
  },
  "KBinsDiscretizer": {
    "name": "sklearn.preprocessing._discretization.KBinsDiscretizer",
    "common_name": "KBinsDiscretizer",
    "description": "Bin continuous data into intervals. Read more in the :ref:`User Guide <preprocessing_discretization>`.  .. versionadded:: 0.20",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "n_bins",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_bins"
          ],
          "default": "n_bins__int",
          "description": "The number of bins to produce. Raises ValueError if ``n_bins < 2``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "n_bins__int",
            "init_args": {
              "semantic_types": [
                "n_bins"
              ],
              "_structural_type": "int",
              "default": 5
            }
          },
          {
            "name": "n_bins__ndarray",
            "type": "Hyperparameter",
            "init_args": {
              "_structural_type": "ndarray",
              "semantic_types": [
                "n_bins"
              ]
            }
          }
        ]
      },
      {
        "type": "Enumeration",
        "name": "encode",
        "init_args": {
          "semantic_types": [
            "encode"
          ],
          "values": [
            "onehot",
            "onehot-dense",
            "ordinal"
          ],
          "_structural_type": "str",
          "default": "onehot",
          "description": "Method used to encode the transformed result.  onehot     Encode the transformed result with one-hot encoding     and return a sparse matrix. Ignored features are always     stacked to the right. onehot-dense     Encode the transformed result with one-hot encoding     and return a dense array. Ignored features are always     stacked to the right. ordinal     Return the bin identifier encoded as an integer value."
        }
      },
      {
        "type": "Enumeration",
        "name": "strategy",
        "init_args": {
          "semantic_types": [
            "strategy"
          ],
          "values": [
            "Uniform",
            "quantile",
            "kmeans"
          ],
          "_structural_type": "str",
          "default": "quantile",
          "description": "Strategy used to define the widths of the bins.  uniform     All bins in each feature have identical widths. quantile     All bins in each feature have the same number of points. kmeans     Values in each bin have the same nearest center of a 1D k-means     cluster."
        }
      },
      {
        "name": "dtype",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "dtype"
          ],
          "default": "dtype__None",
          "description": "The desired data-type for the output. If None, output dtype is consistent with input dtype. Only np.float32 and np.float64 are supported.  .. versionadded:: 0.24"
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "dtype__None",
            "init_args": {
              "semantic_types": [
                "dtype"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      }
    ],
    "Params": [
      {
        "name": "n_bins_",
        "type": "ndarray of shape (n_features,), dtype=np.int_",
        "description": "Number of bins per feature. Bins whose width are too small (i.e., <= 1e-8) are removed with a warning."
      },
      {
        "name": "bin_edges_",
        "type": "ndarray of ndarray of shape (n_features,)",
        "description": "The edges of each bin. Contain arrays of varying shapes ``(n_bins_, )`` Ignored features will have empty arrays."
      }
    ]
  },
  "KernelCenterer": {
    "name": "sklearn.preprocessing._data.KernelCenterer",
    "common_name": "KernelCenterer",
    "description": "Center a kernel matrix. Let K(x, z) be a kernel defined by phi(x)^T phi(z), where phi is a function mapping x to a Hilbert space. KernelCenterer centers (i.e., normalize to have zero mean) the data without explicitly computing phi(x). It is equivalent to centering phi(x) with sklearn.preprocessing.StandardScaler(with_std=False).  Read more in the :ref:`User Guide <kernel_centering>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [],
    "Params": [
      {
        "name": "K_fit_rows_",
        "type": "array of shape (n_samples,)",
        "description": "Average of each column of kernel matrix."
      },
      {
        "name": "K_fit_all_",
        "type": "float",
        "description": "Average of kernel matrix."
      }
    ]
  },
  "LabelBinarizer": {
    "name": "sklearn.preprocessing._label.LabelBinarizer",
    "common_name": "LabelBinarizer",
    "description": "Binarize labels in a one-vs-all fashion. Several regression and binary classification algorithms are available in scikit-learn. A simple way to extend these algorithms to the multi-class classification case is to use the so-called one-vs-all scheme.  At learning time, this simply consists in learning one regressor or binary classifier per class. In doing so, one needs to convert multi-class labels to binary labels (belong or does not belong to the class). LabelBinarizer makes this process easy with the transform method.  At prediction time, one assigns the class for which the corresponding model gave the greatest confidence. LabelBinarizer makes this easy with the inverse_transform method.  Read more in the :ref:`User Guide <preprocessing_targets>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "neg_label",
        "init_args": {
          "semantic_types": [
            "neg_label"
          ],
          "_structural_type": "int",
          "default": 0,
          "description": "Value with which negative labels must be encoded."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "pos_label",
        "init_args": {
          "semantic_types": [
            "pos_label"
          ],
          "_structural_type": "int",
          "default": 1,
          "description": "Value with which positive labels must be encoded."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "sparse_output",
        "init_args": {
          "semantic_types": [
            "sparse_output"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "True if the returned array from transform is desired to be in sparse CSR format."
        }
      }
    ],
    "Params": [
      {
        "name": "classes_",
        "type": "ndarray of shape (n_classes,)",
        "description": "Holds the label for each class."
      },
      {
        "name": "y_type_",
        "type": "str",
        "description": "Represents the type of the target data as evaluated by utils.multiclass.type_of_target. Possible type are 'continuous', 'continuous-multioutput', 'binary', 'multiclass', 'multiclass-multioutput', 'multilabel-indicator', and 'unknown'."
      },
      {
        "name": "sparse_input_",
        "type": "bool",
        "description": "True if the input data to transform is given as a sparse matrix, False otherwise."
      }
    ]
  },
  "LabelEncoder": {
    "name": "sklearn.preprocessing._label.LabelEncoder",
    "common_name": "LabelEncoder",
    "description": "Encode target labels with value between 0 and n_classes-1. This transformer should be used to encode target values, *i.e.* `y`, and not the input `X`.  Read more in the :ref:`User Guide <preprocessing_targets>`.  .. versionadded:: 0.12",
    "sklearn_version": "0.24.0",
    "Hyperparams": [],
    "Params": [
      {
        "name": "classes_",
        "type": "ndarray of shape (n_classes,)",
        "description": "Holds the label for each class."
      }
    ]
  },
  "MaxAbsScaler": {
    "name": "sklearn.preprocessing._data.MaxAbsScaler",
    "common_name": "MaxAbsScaler",
    "description": "Scale each feature by its maximum absolute value. This estimator scales and translates each feature individually such that the maximal absolute value of each feature in the training set will be 1.0. It does not shift/center the data, and thus does not destroy any sparsity.  This scaler can also be applied to sparse CSR or CSC matrices.  .. versionadded:: 0.17",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array)."
        }
      }
    ],
    "Params": [
      {
        "name": "scale_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature relative scaling of the data.  .. versionadded:: 0.17    *scale_* attribute."
      },
      {
        "name": "max_abs_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature maximum absolute value."
      },
      {
        "name": "n_samples_seen_",
        "type": "int",
        "description": "The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across ``partial_fit`` calls."
      }
    ]
  },
  "MinMaxScaler": {
    "name": "sklearn.preprocessing._data.MinMaxScaler",
    "common_name": "MinMaxScaler",
    "description": "Transform features by scaling each feature to a given range. This estimator scales and translates each feature individually such that it is in the given range on the training set, e.g. between zero and one.  The transformation is given by::      X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))     X_scaled = X_std * (max - min) + min  where min, max = feature_range.  This transformation is often used as an alternative to zero mean, unit variance scaling.  Read more in the :ref:`User Guide <preprocessing_scaler>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "feature_range",
        "init_args": {
          "semantic_types": [
            "feature_range"
          ],
          "_structural_type": "tuple",
          "default": "&esc(0, 1)",
          "description": "Desired range of transformed data."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array)."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "clip",
        "init_args": {
          "semantic_types": [
            "clip"
          ],
          "_structural_type": "bool",
          "default": "False"
        }
      }
    ],
    "Params": [
      {
        "name": "min_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature adjustment for minimum. Equivalent to ``min - X.min(axis=0) * self.scale_``"
      },
      {
        "name": "scale_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature relative scaling of the data. Equivalent to ``(max - min) / (X.max(axis=0) - X.min(axis=0))``  .. versionadded:: 0.17    *scale_* attribute."
      },
      {
        "name": "data_min_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature minimum seen in the data  .. versionadded:: 0.17    *data_min_*"
      },
      {
        "name": "data_max_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature maximum seen in the data  .. versionadded:: 0.17    *data_max_*"
      },
      {
        "name": "data_range_",
        "type": "ndarray of shape (n_features,)",
        "description": "Per feature range ``(data_max_ - data_min_)`` seen in the data  .. versionadded:: 0.17    *data_range_*"
      },
      {
        "name": "n_samples_seen_",
        "type": "int",
        "description": "The number of samples processed by the estimator. It will be reset on new calls to fit, but increments across ``partial_fit`` calls."
      }
    ]
  },
  "MultiLabelBinarizer": {
    "name": "sklearn.preprocessing._label.MultiLabelBinarizer",
    "common_name": "MultiLabelBinarizer",
    "description": "Transform between iterable of iterables and a multilabel format. Although a list of sets or tuples is a very intuitive format for multilabel data, it is unwieldy to process. This transformer converts between this intuitive format and the supported multilabel format: a (samples x classes) binary matrix indicating the presence of a class label.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "classes",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "classes"
          ],
          "default": "classes__None",
          "description": "Indicates an ordering for the class labels. All entries should be unique (cannot contain duplicate classes)."
        },
        "hyperparams": [
          {
            "name": "classes__ndarray",
            "type": "Hyperparameter",
            "init_args": {
              "_structural_type": "ndarray",
              "semantic_types": [
                "classes"
              ]
            }
          },
          {
            "type": "Constant",
            "name": "classes__None",
            "init_args": {
              "semantic_types": [
                "classes"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "sparse_output",
        "init_args": {
          "semantic_types": [
            "sparse_output"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Set to True if output binary array is desired in CSR sparse format."
        }
      }
    ],
    "Params": [
      {
        "name": "classes_",
        "type": "ndarray of shape (n_classes,)",
        "description": "A copy of the `classes` parameter when provided. Otherwise it corresponds to the sorted set of classes found when fitting."
      }
    ]
  },
  "Normalizer": {
    "name": "sklearn.preprocessing._data.Normalizer",
    "common_name": "Normalizer",
    "description": "Normalize samples individually to unit norm. Each sample (i.e. each row of the data matrix) with at least one non zero component is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one.  This transformer is able to work both with dense numpy arrays and scipy.sparse matrix (use CSR format if you want to avoid the burden of a copy / conversion).  Scaling inputs to unit norms is a common operation for text classification or clustering for instance. For instance the dot product of two l2-normalized TF-IDF vectors is the cosine similarity of the vectors and is the base similarity metric for the Vector Space Model commonly used by the Information Retrieval community.  Read more in the :ref:`User Guide <preprocessing_normalization>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "norm",
        "init_args": {
          "semantic_types": [
            "norm"
          ],
          "values": [
            "l1",
            "l2",
            "max"
          ],
          "_structural_type": "str",
          "default": "l2",
          "description": "The norm to use to normalize each non zero sample. If norm='max' is used, values will be rescaled by the maximum of the absolute values."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix)."
        }
      }
    ],
    "Params": []
  },
  "OneHotEncoder": {
    "name": "sklearn.preprocessing._encoders.OneHotEncoder",
    "common_name": "OneHotEncoder",
    "description": "Encode categorical features as a one-hot numeric array. The input to this transformer should be an array-like of integers or strings, denoting the values taken on by categorical (discrete) features. The features are encoded using a one-hot (aka 'one-of-K' or 'dummy') encoding scheme. This creates a binary column for each category and returns a sparse matrix or dense array (depending on the ``sparse`` parameter)  By default, the encoder derives the categories based on the unique values in each feature. Alternatively, you can also specify the `categories` manually.  This encoding is needed for feeding categorical data to many scikit-learn estimators, notably linear models and SVMs with the standard kernels.  Note: a one-hot encoding of y labels should use a LabelBinarizer instead.  Read more in the :ref:`User Guide <preprocessing_categorical_features>`.  .. versionchanged:: 0.20",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "categories",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "categories"
          ],
          "default": "categories__str",
          "description": "Categories (unique values) per feature:  - 'auto' : Determine categories automatically from the training data. - list : ``categories[i]`` holds the categories expected in the ith   column. The passed categories should not mix strings and numeric   values within a single feature, and should be sorted in case of   numeric values.  The used categories can be found in the ``categories_`` attribute.  .. versionadded:: 0.20"
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "categories__str",
            "init_args": {
              "semantic_types": [
                "categories"
              ],
              "_structural_type": "str",
              "default": "auto"
            }
          },
          {
            "name": "categories__ndarray",
            "type": "Hyperparameter",
            "init_args": {
              "_structural_type": "ndarray",
              "semantic_types": [
                "categories"
              ]
            }
          }
        ]
      },
      {
        "name": "drop",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "drop"
          ],
          "default": "drop__None",
          "description": "Specifies a methodology to use to drop one of the categories per feature. This is useful in situations where perfectly collinear features cause problems, such as when feeding the resulting data into a neural network or an unregularized regression.  However, dropping one category breaks the symmetry of the original representation and can therefore induce a bias in downstream models, for instance for penalized linear classification or regression models.  - None : retain all features (the default). - 'first' : drop the first category in each feature. If only one   category is present, the feature will be dropped entirely. - 'if_binary' : drop the first category in each feature with two   categories. Features with 1 or more than 2 categories are   left intact. - array : ``drop[i]`` is the category in feature ``X[:, i]`` that   should be dropped.  .. versionchanged:: 0.23    Added option 'if_binary'."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "drop__str",
            "init_args": {
              "semantic_types": [
                "drop"
              ],
              "values": [
                "first",
                "if_binary"
              ],
              "_structural_type": "str"
            }
          },
          {
            "name": "drop__ndarray",
            "type": "Hyperparameter",
            "init_args": {
              "_structural_type": "ndarray",
              "semantic_types": [
                "drop"
              ]
            }
          },
          {
            "type": "Constant",
            "name": "drop__None",
            "init_args": {
              "semantic_types": [
                "drop"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "sparse",
        "init_args": {
          "semantic_types": [
            "sparse"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Will return sparse matrix if set True else will return an array."
        }
      },
      {
        "type": "Enumeration",
        "name": "handle_unknown",
        "init_args": {
          "semantic_types": [
            "handle_unknown"
          ],
          "values": [
            "error",
            "ignore"
          ],
          "_structural_type": "str",
          "default": "error",
          "description": "Whether to raise an error or ignore if an unknown categorical feature is present during transform (default is to raise). When this parameter is set to 'ignore' and an unknown category is encountered during transform, the resulting one-hot encoded columns for this feature will be all zeros. In the inverse transform, an unknown category will be denoted as None."
        }
      }
    ],
    "Params": [
      {
        "name": "categories_",
        "type": "list of arrays",
        "description": "The categories of each feature determined during fitting (in order of the features in X and corresponding with the output of ``transform``). This includes the category specified in ``drop`` (if any)."
      },
      {
        "name": "drop_idx_",
        "type": "array of shape (n_features,)",
        "description": "- ``drop_idx_[i]`` is\u00a0the index in ``categories_[i]`` of the category   to be dropped for each feature. - ``drop_idx_[i] = None`` if no category is to be dropped from the   feature with index ``i``, e.g. when `drop='if_binary'` and the   feature isn't binary. - ``drop_idx_ = None`` if all the transformed features will be   retained.  .. versionchanged:: 0.23    Added the possibility to contain `None` values."
      }
    ]
  },
  "OrdinalEncoder": {
    "name": "sklearn.preprocessing._encoders.OrdinalEncoder",
    "common_name": "OrdinalEncoder",
    "description": "Encode categorical features as an integer array. The input to this transformer should be an array-like of integers or strings, denoting the values taken on by categorical (discrete) features. The features are converted to ordinal integers. This results in a single column of integers (0 to n_categories - 1) per feature.  Read more in the :ref:`User Guide <preprocessing_categorical_features>`.  .. versionadded:: 0.20",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "categories",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "categories"
          ],
          "default": "categories__str",
          "description": "Categories (unique values) per feature:  - 'auto' : Determine categories automatically from the training data. - list : ``categories[i]`` holds the categories expected in the ith   column. The passed categories should not mix strings and numeric   values, and should be sorted in case of numeric values.  The used categories can be found in the ``categories_`` attribute."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "categories__str",
            "init_args": {
              "semantic_types": [
                "categories"
              ],
              "_structural_type": "str",
              "default": "auto"
            }
          },
          {
            "name": "categories__ndarray",
            "type": "Hyperparameter",
            "init_args": {
              "_structural_type": "ndarray",
              "semantic_types": [
                "categories"
              ]
            }
          }
        ]
      },
      {
        "type": "Enumeration",
        "name": "handle_unknown",
        "init_args": {
          "semantic_types": [
            "handle_unknown"
          ],
          "values": [
            "error",
            "ignore"
          ],
          "_structural_type": "str",
          "default": "error",
          "description": "When set to 'error' an error will be raised in case an unknown categorical feature is present during transform. When set to 'use_encoded_value', the encoded value of unknown categories will be set to the value given for the parameter `unknown_value`. In :meth:`inverse_transform`, an unknown category will be denoted as None.  .. versionadded:: 0.24"
        }
      },
      {
        "name": "unknown_value",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "unknown_value"
          ],
          "default": "unknown_value__None",
          "description": "When the parameter handle_unknown is set to 'use_encoded_value', this parameter is required and will set the encoded value of unknown categories. It has to be distinct from the values used to encode any of the categories in `fit`. If set to np.nan, the `dtype` parameter must be a float dtype.  .. versionadded:: 0.24"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "unknown_value__int",
            "init_args": {
              "semantic_types": [
                "unknown_value"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "unknown_value__float",
            "init_args": {
              "semantic_types": [
                "unknown_value"
              ],
              "_structural_type": "float"
            }
          },
          {
            "type": "Constant",
            "name": "unknown_value__None",
            "init_args": {
              "semantic_types": [
                "unknown_value"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      }
    ],
    "Params": [
      {
        "name": "categories_",
        "type": "list of arrays",
        "description": "The categories of each feature determined during ``fit`` (in order of the features in X and corresponding with the output of ``transform``). This does not include categories that weren't seen during ``fit``."
      }
    ]
  },
  "PolynomialFeatures": {
    "name": "sklearn.preprocessing._data.PolynomialFeatures",
    "common_name": "PolynomialFeatures",
    "description": "Generate polynomial and interaction features. Generate a new feature matrix consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. For example, if an input sample is two dimensional and of the form [a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "degree",
        "init_args": {
          "semantic_types": [
            "degree"
          ],
          "_structural_type": "int",
          "default": 2,
          "description": "The degree of the polynomial features."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "interaction_only",
        "init_args": {
          "semantic_types": [
            "interaction_only"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If true, only interaction features are produced: features that are products of at most ``degree`` *distinct* input features (so not ``x[1] ** 2``, ``x[0] * x[2] ** 3``, etc.)."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "include_bias",
        "init_args": {
          "semantic_types": [
            "include_bias"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True (default), then include a bias column, the feature in which all polynomial powers are zero (i.e. a column of ones - acts as an intercept term in a linear model)."
        }
      },
      {
        "type": "Enumeration",
        "name": "order",
        "init_args": {
          "semantic_types": [
            "order"
          ],
          "values": [
            "C",
            "F"
          ],
          "_structural_type": "str",
          "default": "C",
          "description": "Order of output array in the dense case. 'F' order is faster to compute, but may slow down subsequent estimators.  .. versionadded:: 0.21"
        }
      }
    ],
    "Params": [
      {
        "name": "powers_",
        "type": "ndarray of shape (n_output_features, n_input_features)",
        "description": "powers_[i, j] is the exponent of the jth input in the ith output."
      },
      {
        "name": "n_input_features_",
        "type": "int",
        "description": "The total number of input features."
      },
      {
        "name": "n_output_features_",
        "type": "int",
        "description": "The total number of polynomial output features. The number of output features is computed by iterating over all suitably sized combinations of input features."
      }
    ]
  },
  "PowerTransformer": {
    "name": "sklearn.preprocessing._data.PowerTransformer",
    "common_name": "PowerTransformer",
    "description": "Apply a power transform featurewise to make data more Gaussian-like. Power transforms are a family of parametric, monotonic transformations that are applied to make data more Gaussian-like. This is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired.  Currently, PowerTransformer supports the Box-Cox transform and the Yeo-Johnson transform. The optimal parameter for stabilizing variance and minimizing skewness is estimated through maximum likelihood.  Box-Cox requires input data to be strictly positive, while Yeo-Johnson supports both positive or negative data.  By default, zero-mean, unit-variance normalization is applied to the transformed data.  Read more in the :ref:`User Guide <preprocessing_transformer>`.  .. versionadded:: 0.20",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "method",
        "init_args": {
          "semantic_types": [
            "method"
          ],
          "values": [
            "yeo-johnson",
            "box-cox"
          ],
          "_structural_type": "str",
          "default": "yeo-johnson",
          "description": "The power transform method. Available methods are:  - 'yeo-johnson' [1]_, works with positive and negative values - 'box-cox' [2]_, only works with strictly positive values"
        }
      },
      {
        "type": "Hyperparameter",
        "name": "standardize",
        "init_args": {
          "semantic_types": [
            "standardize"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Set to True to apply zero-mean, unit-variance normalization to the transformed output."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Set to False to perform inplace computation during transformation."
        }
      }
    ],
    "Params": [
      {
        "name": "lambdas_",
        "type": "ndarray of float of shape (n_features,)",
        "description": "The parameters of the power transformation for the selected features."
      }
    ]
  },
  "QuantileTransformer": {
    "name": "sklearn.preprocessing._data.QuantileTransformer",
    "common_name": "QuantileTransformer",
    "description": "Transform features using quantiles information. This method transforms the features to follow a uniform or a normal distribution. Therefore, for a given feature, this transformation tends to spread out the most frequent values. It also reduces the impact of (marginal) outliers: this is therefore a robust preprocessing scheme.  The transformation is applied on each feature independently. First an estimate of the cumulative distribution function of a feature is used to map the original values to a uniform distribution. The obtained values are then mapped to the desired output distribution using the associated quantile function. Features values of new/unseen data that fall below or above the fitted range will be mapped to the bounds of the output distribution. Note that this transform is non-linear. It may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable.  Read more in the :ref:`User Guide <preprocessing_transformer>`.  .. versionadded:: 0.19",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "n_quantiles",
        "init_args": {
          "semantic_types": [
            "n_quantiles"
          ],
          "_structural_type": "int",
          "default": 1000,
          "description": "Number of quantiles to be computed. It corresponds to the number of landmarks used to discretize the cumulative distribution function. If n_quantiles is larger than the number of samples, n_quantiles is set to the number of samples as a larger number of quantiles does not give a better approximation of the cumulative distribution function estimator."
        }
      },
      {
        "type": "Enumeration",
        "name": "output_distribution",
        "init_args": {
          "semantic_types": [
            "output_distribution"
          ],
          "values": [
            "uniform",
            "normal"
          ],
          "_structural_type": "str",
          "default": "uniform",
          "description": "Marginal distribution for the transformed data. The choices are 'uniform' (default) or 'normal'."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "ignore_implicit_zeros",
        "init_args": {
          "semantic_types": [
            "ignore_implicit_zeros"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Only applies to sparse matrices. If True, the sparse entries of the matrix are discarded to compute the quantile statistics. If False, these entries are treated as zeros."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "subsample",
        "init_args": {
          "semantic_types": [
            "subsample"
          ],
          "_structural_type": "int",
          "default": 100000,
          "description": "Maximum number of samples used to estimate the quantiles for computational efficiency. Note that the subsampling procedure may differ for value-identical sparse and dense matrices."
        }
      },
      {
        "name": "random_state",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "random_state"
          ],
          "default": "random_state__None",
          "description": "Determines random number generation for subsampling and smoothing noise. Please see ``subsample`` for more details. Pass an int for reproducible results across multiple function calls. See :term:`Glossary <random_state>`"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "random_state__int",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "random_state__None",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Set to False to perform inplace transformation and avoid a copy (if the input is already a numpy array)."
        }
      }
    ],
    "Params": [
      {
        "name": "n_quantiles_",
        "type": "int",
        "description": "The actual number of quantiles used to discretize the cumulative distribution function."
      },
      {
        "name": "quantiles_",
        "type": "ndarray of shape (n_quantiles, n_features)",
        "description": "The values corresponding the quantiles of reference."
      },
      {
        "name": "references_",
        "type": "ndarray of shape (n_quantiles, )",
        "description": "Quantiles of references."
      }
    ]
  },
  "RobustScaler": {
    "name": "sklearn.preprocessing._data.RobustScaler",
    "common_name": "RobustScaler",
    "description": "Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the quantile range (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and the 3rd quartile (75th quantile).  Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Median and interquartile range are then stored to be used on later data using the ``transform`` method.  Standardization of a dataset is a common requirement for many machine learning estimators. Typically this is done by removing the mean and scaling to unit variance. However, outliers can often influence the sample mean / variance in a negative way. In such cases, the median and the interquartile range often give better results.  .. versionadded:: 0.17  Read more in the :ref:`User Guide <preprocessing_scaler>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "with_centering",
        "init_args": {
          "semantic_types": [
            "with_centering"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, center the data before scaling. This will cause ``transform`` to raise an exception when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "with_scaling",
        "init_args": {
          "semantic_types": [
            "with_scaling"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, scale the data to interquartile range."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "quantile_range",
        "init_args": {
          "semantic_types": [
            "quantile_range"
          ],
          "_structural_type": "tuple",
          "default": "&esc(25.0, 75.0)",
          "description": "Quantile range used to calculate ``scale_``.  .. versionadded:: 0.18"
        }
      },
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If False, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "unit_variance",
        "init_args": {
          "semantic_types": [
            "unit_variance"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If True, scale data so that normally distributed features have a variance of 1. In general, if the difference between the x-values of ``q_max`` and ``q_min`` for a standard normal distribution is greater than 1, the dataset will be scaled down. If less than 1, the dataset will be scaled up.  .. versionadded:: 0.24"
        }
      }
    ],
    "Params": [
      {
        "name": "center_",
        "type": "array of floats",
        "description": "The median value for each feature in the training set."
      },
      {
        "name": "scale_",
        "type": "array of floats",
        "description": "The (scaled) interquartile range for each feature in the training set.  .. versionadded:: 0.17    *scale_* attribute."
      }
    ]
  },
  "StandardScaler": {
    "name": "sklearn.preprocessing._data.StandardScaler",
    "common_name": "StandardScaler",
    "description": "Standardize features by removing the mean and scaling to unit variance The standard score of a sample `x` is calculated as:      z = (x - u) / s  where `u` is the mean of the training samples or zero if `with_mean=False`, and `s` is the standard deviation of the training samples or one if `with_std=False`.  Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Mean and standard deviation are then stored to be used on later data using :meth:`transform`.  Standardization of a dataset is a common requirement for many machine learning estimators: they might behave badly if the individual features do not more or less look like standard normally distributed data (e.g. Gaussian with 0 mean and unit variance).  For instance many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the L1 and L2 regularizers of linear models) assume that all features are centered around 0 and have variance in the same order. If a feature has a variance that is orders of magnitude larger that others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.  This scaler can also be applied to sparse CSR or CSC matrices by passing `with_mean=False` to avoid breaking the sparsity structure of the data.  Read more in the :ref:`User Guide <preprocessing_scaler>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "copy",
        "init_args": {
          "semantic_types": [
            "copy"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If False, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "with_mean",
        "init_args": {
          "semantic_types": [
            "with_mean"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, center the data before scaling. This does not work (and will raise an exception) when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "with_std",
        "init_args": {
          "semantic_types": [
            "with_std"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, scale the data to unit variance (or equivalently, unit standard deviation)."
        }
      }
    ],
    "Params": [
      {
        "name": "scale_",
        "type": "ndarray of shape (n_features,) or None",
        "description": "Per feature relative scaling of the data. This is calculated using `np.sqrt(var_)`. Equal to ``None`` when ``with_std=False``.  .. versionadded:: 0.17    *scale_*"
      },
      {
        "name": "mean_",
        "type": "ndarray of shape (n_features,) or None",
        "description": "The mean value for each feature in the training set. Equal to ``None`` when ``with_mean=False``."
      },
      {
        "name": "var_",
        "type": "ndarray of shape (n_features,) or None",
        "description": "The variance for each feature in the training set. Used to compute `scale_`. Equal to ``None`` when ``with_std=False``."
      },
      {
        "name": "n_samples_seen_",
        "type": "int or ndarray of shape (n_features,)",
        "description": "The number of samples processed by the estimator for each feature. If there are no missing samples, the ``n_samples_seen`` will be an integer, otherwise it will be an array of dtype int. If `sample_weights` are used it will be a float (if no missing data) or an array of dtype float that sums the weights seen so far. Will be reset on new calls to fit, but increments across ``partial_fit`` calls."
      }
    ]
  }
}