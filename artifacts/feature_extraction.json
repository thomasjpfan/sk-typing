{
  "CountVectorizer": {
    "name": "sklearn.feature_extraction.text.CountVectorizer",
    "common_name": "CountVectorizer",
    "description": "Convert a collection of text documents to a matrix of token counts This implementation produces a sparse representation of the counts using scipy.sparse.csr_matrix.  If you do not provide an a-priori dictionary and you do not use an analyzer that does some kind of feature selection then the number of features will be equal to the vocabulary size found by analyzing the data.  Read more in the :ref:`User Guide <text_feature_extraction>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "input",
        "init_args": {
          "semantic_types": [
            "input"
          ],
          "values": [
            "filename",
            "file",
            "content"
          ],
          "_structural_type": "str",
          "default": "content",
          "description": "If 'filename', the sequence passed as an argument to fit is expected to be a list of filenames that need reading to fetch the raw content to analyze.  If 'file', the sequence items must have a 'read' method (file-like object) that is called to fetch the bytes in memory.  Otherwise the input is expected to be a sequence of items that can be of type string or byte."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "encoding",
        "init_args": {
          "semantic_types": [
            "encoding"
          ],
          "_structural_type": "str",
          "default": "utf-8",
          "description": "If bytes or files are given to analyze, this encoding is used to decode."
        }
      },
      {
        "type": "Enumeration",
        "name": "decode_error",
        "init_args": {
          "semantic_types": [
            "decode_error"
          ],
          "values": [
            "strict",
            "ignore",
            "replace"
          ],
          "_structural_type": "str",
          "default": "strict",
          "description": "Instruction on what to do if a byte sequence is given to analyze that contains characters not of the given `encoding`. By default, it is 'strict', meaning that a UnicodeDecodeError will be raised. Other values are 'ignore' and 'replace'."
        }
      },
      {
        "name": "strip_accents",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "strip_accents"
          ],
          "default": "strip_accents__None",
          "description": "Remove accents and perform other character normalization during the preprocessing step. 'ascii' is a fast method that only works on characters that have an direct ASCII mapping. 'unicode' is a slightly slower method that works on any characters. None (default) does nothing.  Both 'ascii' and 'unicode' use NFKD normalization from :func:`unicodedata.normalize`."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "strip_accents__str",
            "init_args": {
              "semantic_types": [
                "strip_accents"
              ],
              "values": [
                "ascii",
                "unicode"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Constant",
            "name": "strip_accents__None",
            "init_args": {
              "semantic_types": [
                "strip_accents"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "lowercase",
        "init_args": {
          "semantic_types": [
            "lowercase"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Convert all characters to lowercase before tokenizing."
        }
      },
      {
        "name": "preprocessor",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "preprocessor"
          ],
          "default": "preprocessor__None",
          "description": "Override the preprocessing (strip_accents and lowercase) stage while preserving the tokenizing and n-grams generation steps. Only applies if ``analyzer is not callable``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "preprocessor__Callable",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "preprocessor__None",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "tokenizer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "tokenizer"
          ],
          "default": "tokenizer__None",
          "description": "Override the string tokenization step while preserving the preprocessing and n-grams generation steps. Only applies if ``analyzer == 'word'``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "tokenizer__Callable",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "tokenizer__None",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "stop_words",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "stop_words"
          ],
          "default": "stop_words__None",
          "description": "If 'english', a built-in stop word list for English is used. There are several known issues with 'english' and you should consider an alternative (see :ref:`stop_words`).  If a list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens. Only applies if ``analyzer == 'word'``.  If None, no stop words will be used. max_df can be set to a value in the range [0.7, 1.0) to automatically detect and filter stop words based on intra corpus document frequency of terms."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "stop_words__str",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "stop_words__Callable",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "stop_words__None",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "token_pattern",
        "init_args": {
          "semantic_types": [
            "token_pattern"
          ],
          "_structural_type": "str",
          "default": "(?u)\\b\\w\\w+\\b",
          "description": "Regular expression denoting what constitutes a \"token\", only used if ``analyzer == 'word'``. The default regexp select tokens of 2 or more alphanumeric characters (punctuation is completely ignored and always treated as a token separator).  If there is a capturing group in token_pattern then the captured group content, not the entire match, becomes the token. At most one capturing group is permitted."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "ngram_range",
        "init_args": {
          "semantic_types": [
            "ngram_range"
          ],
          "_structural_type": "tuple",
          "default": "&esc(1, 1)",
          "description": "The lower and upper boundary of the range of n-values for different word n-grams or char n-grams to be extracted. All values of n such such that min_n <= n <= max_n will be used. For example an ``ngram_range`` of ``(1, 1)`` means only unigrams, ``(1, 2)`` means unigrams and bigrams, and ``(2, 2)`` means only bigrams. Only applies if ``analyzer is not callable``."
        }
      },
      {
        "name": "analyzer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "analyzer"
          ],
          "default": "analyzer__str",
          "description": "Whether the feature should be made of word n-gram or character n-grams. Option 'char_wb' creates character n-grams only from text inside word boundaries; n-grams at the edges of words are padded with space.  If a callable is passed it is used to extract the sequence of features out of the raw, unprocessed input.  .. versionchanged:: 0.21  Since v0.21, if ``input`` is ``filename`` or ``file``, the data is first read from the file and then passed to the given callable analyzer."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "analyzer__str",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "values": [
                "word",
                "char",
                "char_wb"
              ],
              "_structural_type": "str",
              "default": "word"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "analyzer__Callable",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "_structural_type": "Callable"
            }
          }
        ]
      },
      {
        "name": "max_df",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_df"
          ],
          "default": "max_df__float",
          "description": "When building the vocabulary ignore terms that have a document frequency strictly higher than the given threshold (corpus-specific stop words). If float, the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "max_df__float",
            "init_args": {
              "semantic_types": [
                "max_df"
              ],
              "_structural_type": "float",
              "default": 1.0
            }
          },
          {
            "type": "Hyperparameter",
            "name": "max_df__int",
            "init_args": {
              "semantic_types": [
                "max_df"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "name": "min_df",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "min_df"
          ],
          "default": "min_df__int",
          "description": "When building the vocabulary ignore terms that have a document frequency strictly lower than the given threshold. This value is also called cut-off in the literature. If float, the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "min_df__float",
            "init_args": {
              "semantic_types": [
                "min_df"
              ],
              "_structural_type": "float"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "min_df__int",
            "init_args": {
              "semantic_types": [
                "min_df"
              ],
              "_structural_type": "int",
              "default": 1
            }
          }
        ]
      },
      {
        "name": "max_features",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_features"
          ],
          "default": "max_features__None",
          "description": "If not None, build a vocabulary that only consider the top max_features ordered by term frequency across the corpus.  This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "max_features__int",
            "init_args": {
              "semantic_types": [
                "max_features"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "max_features__None",
            "init_args": {
              "semantic_types": [
                "max_features"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "vocabulary",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "vocabulary"
          ],
          "default": "vocabulary__None",
          "description": "Either a Mapping (e.g., a dict) where keys are terms and values are indices in the feature matrix, or an iterable over terms. If not given, a vocabulary is determined from the input documents. Indices in the mapping should not be repeated and should not have any gap between 0 and the largest index."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "vocabulary__None",
            "init_args": {
              "semantic_types": [
                "vocabulary"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "binary",
        "init_args": {
          "semantic_types": [
            "binary"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If True, all non zero counts are set to 1. This is useful for discrete probabilistic models that model binary events rather than integer counts."
        }
      }
    ],
    "Params": [
      {
        "name": "vocabulary_",
        "type": "dict",
        "description": "A mapping of terms to feature indices."
      },
      {
        "name": "fixed_vocabulary_: boolean",
        "type": "",
        "description": "True if a fixed vocabulary of term to indices mapping is provided by the user"
      },
      {
        "name": "stop_words_",
        "type": "set",
        "description": "Terms that were ignored because they either:    - occurred in too many documents (`max_df`)   - occurred in too few documents (`min_df`)   - were cut off by feature selection (`max_features`).  This is only available if no vocabulary was given."
      }
    ]
  },
  "DictVectorizer": {
    "name": "sklearn.feature_extraction._dict_vectorizer.DictVectorizer",
    "common_name": "DictVectorizer",
    "description": "Transforms lists of feature-value mappings to vectors. This transformer turns lists of mappings (dict-like objects) of feature names to feature values into Numpy arrays or scipy.sparse matrices for use with scikit-learn estimators.  When feature values are strings, this transformer will do a binary one-hot (aka one-of-K) coding: one boolean-valued feature is constructed for each of the possible string values that the feature can take on. For instance, a feature \"f\" that can take on the values \"ham\" and \"spam\" will become two features in the output, one signifying \"f=ham\", the other \"f=spam\".  If a feature value is a sequence or set of strings, this transformer will iterate over the values and will count the occurrences of each string value.  However, note that this transformer will only do a binary one-hot encoding when feature values are of type string. If categorical features are represented as numeric values such as int or iterables of strings, the DictVectorizer can be followed by :class:`~sklearn.preprocessing.OneHotEncoder` to complete binary one-hot encoding.  Features that do not occur in a sample (mapping) will have a zero value in the resulting array/matrix.  Read more in the :ref:`User Guide <dict_feature_extraction>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "separator",
        "init_args": {
          "semantic_types": [
            "separator"
          ],
          "_structural_type": "str",
          "default": "=",
          "description": "Separator string used when constructing new features for one-hot coding."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "sparse",
        "init_args": {
          "semantic_types": [
            "sparse"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Whether transform should produce scipy.sparse matrices."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "sort",
        "init_args": {
          "semantic_types": [
            "sort"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Whether ``feature_names_`` and ``vocabulary_`` should be sorted when fitting."
        }
      }
    ],
    "Params": [
      {
        "name": "vocabulary_",
        "type": "dict",
        "description": "A dictionary mapping feature names to feature indices."
      },
      {
        "name": "feature_names_",
        "type": "list",
        "description": "A list of length n_features containing the feature names (e.g., \"f=ham\" and \"f=spam\")."
      }
    ]
  },
  "FeatureHasher": {
    "name": "sklearn.feature_extraction._hash.FeatureHasher",
    "common_name": "FeatureHasher",
    "description": "Implements feature hashing, aka the hashing trick. This class turns sequences of symbolic feature names (strings) into scipy.sparse matrices, using a hash function to compute the matrix column corresponding to a name. The hash function employed is the signed 32-bit version of Murmurhash3.  Feature names of type byte string are used as-is. Unicode strings are converted to UTF-8 first, but no Unicode normalization is done. Feature values must be (finite) numbers.  This class is a low-memory alternative to DictVectorizer and CountVectorizer, intended for large-scale (online) learning and situations where memory is tight, e.g. when running prediction code on embedded devices.  Read more in the :ref:`User Guide <feature_hashing>`.  .. versionadded:: 0.13",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "n_features",
        "init_args": {
          "semantic_types": [
            "n_features"
          ],
          "_structural_type": "int",
          "default": 1048576,
          "description": "The number of features (columns) in the output matrices. Small numbers of features are likely to cause hash collisions, but large numbers will cause larger coefficient dimensions in linear learners."
        }
      },
      {
        "type": "Enumeration",
        "name": "input_type",
        "init_args": {
          "semantic_types": [
            "input_type"
          ],
          "values": [
            "dict",
            "pair",
            "string"
          ],
          "_structural_type": "str",
          "default": "dict",
          "description": "Either \"dict\" (the default) to accept dictionaries over (feature_name, value); \"pair\" to accept pairs of (feature_name, value); or \"string\" to accept single strings. feature_name should be a string, while value should be a number. In the case of \"string\", a value of 1 is implied. The feature_name is hashed to find the appropriate column for the feature. The value's sign might be flipped in the output (but see non_negative, below)."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "alternate_sign",
        "init_args": {
          "semantic_types": [
            "alternate_sign"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "When True, an alternating sign is added to the features as to approximately conserve the inner product in the hashed space even for small n_features. This approach is similar to sparse random projection."
        }
      }
    ],
    "Params": []
  },
  "HashingVectorizer": {
    "name": "sklearn.feature_extraction.text.HashingVectorizer",
    "common_name": "HashingVectorizer",
    "description": "Convert a collection of text documents to a matrix of token occurrences It turns a collection of text documents into a scipy.sparse matrix holding token occurrence counts (or binary occurrence information), possibly normalized as token frequencies if norm='l1' or projected on the euclidean unit sphere if norm='l2'.  This text vectorizer implementation uses the hashing trick to find the token string name to feature integer index mapping.  This strategy has several advantages:  - it is very low memory scalable to large datasets as there is no need to   store a vocabulary dictionary in memory  - it is fast to pickle and un-pickle as it holds no state besides the   constructor parameters  - it can be used in a streaming (partial fit) or parallel pipeline as there   is no state computed during fit.  There are also a couple of cons (vs using a CountVectorizer with an in-memory vocabulary):  - there is no way to compute the inverse transform (from feature indices to   string feature names) which can be a problem when trying to introspect   which features are most important to a model.  - there can be collisions: distinct tokens can be mapped to the same   feature index. However in practice this is rarely an issue if n_features   is large enough (e.g. 2 ** 18 for text classification problems).  - no IDF weighting as this would render the transformer stateful.  The hash function employed is the signed 32-bit version of Murmurhash3.  Read more in the :ref:`User Guide <text_feature_extraction>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "input",
        "init_args": {
          "semantic_types": [
            "input"
          ],
          "values": [
            "filename",
            "file",
            "content"
          ],
          "_structural_type": "str",
          "default": "content",
          "description": "If 'filename', the sequence passed as an argument to fit is expected to be a list of filenames that need reading to fetch the raw content to analyze.  If 'file', the sequence items must have a 'read' method (file-like object) that is called to fetch the bytes in memory.  Otherwise the input is expected to be a sequence of items that can be of type string or byte."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "encoding",
        "init_args": {
          "semantic_types": [
            "encoding"
          ],
          "_structural_type": "str",
          "default": "utf-8",
          "description": "If bytes or files are given to analyze, this encoding is used to decode."
        }
      },
      {
        "type": "Enumeration",
        "name": "decode_error",
        "init_args": {
          "semantic_types": [
            "decode_error"
          ],
          "values": [
            "strict",
            "ignore",
            "replace"
          ],
          "_structural_type": "str",
          "default": "strict",
          "description": "Instruction on what to do if a byte sequence is given to analyze that contains characters not of the given `encoding`. By default, it is 'strict', meaning that a UnicodeDecodeError will be raised. Other values are 'ignore' and 'replace'."
        }
      },
      {
        "name": "strip_accents",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "strip_accents"
          ],
          "default": "strip_accents__None",
          "description": "Remove accents and perform other character normalization during the preprocessing step. 'ascii' is a fast method that only works on characters that have an direct ASCII mapping. 'unicode' is a slightly slower method that works on any characters. None (default) does nothing.  Both 'ascii' and 'unicode' use NFKD normalization from :func:`unicodedata.normalize`."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "strip_accents__str",
            "init_args": {
              "semantic_types": [
                "strip_accents"
              ],
              "values": [
                "ascii",
                "unicode"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Constant",
            "name": "strip_accents__None",
            "init_args": {
              "semantic_types": [
                "strip_accents"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "lowercase",
        "init_args": {
          "semantic_types": [
            "lowercase"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Convert all characters to lowercase before tokenizing."
        }
      },
      {
        "name": "preprocessor",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "preprocessor"
          ],
          "default": "preprocessor__None",
          "description": "Override the preprocessing (string transformation) stage while preserving the tokenizing and n-grams generation steps. Only applies if ``analyzer is not callable``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "preprocessor__Callable",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "preprocessor__None",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "tokenizer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "tokenizer"
          ],
          "default": "tokenizer__None",
          "description": "Override the string tokenization step while preserving the preprocessing and n-grams generation steps. Only applies if ``analyzer == 'word'``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "tokenizer__Callable",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "tokenizer__None",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "stop_words",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "stop_words"
          ],
          "default": "stop_words__None",
          "description": "If 'english', a built-in stop word list for English is used. There are several known issues with 'english' and you should consider an alternative (see :ref:`stop_words`).  If a list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens. Only applies if ``analyzer == 'word'``."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "stop_words__str",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "stop_words__list",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "list"
            }
          },
          {
            "type": "Constant",
            "name": "stop_words__None",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "token_pattern",
        "init_args": {
          "semantic_types": [
            "token_pattern"
          ],
          "_structural_type": "str",
          "default": "(?u)\\b\\w\\w+\\b",
          "description": "Regular expression denoting what constitutes a \"token\", only used if ``analyzer == 'word'``. The default regexp selects tokens of 2 or more alphanumeric characters (punctuation is completely ignored and always treated as a token separator).  If there is a capturing group in token_pattern then the captured group content, not the entire match, becomes the token. At most one capturing group is permitted."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "ngram_range",
        "init_args": {
          "semantic_types": [
            "ngram_range"
          ],
          "_structural_type": "tuple",
          "default": "&esc(1, 1)",
          "description": "The lower and upper boundary of the range of n-values for different n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ``ngram_range`` of ``(1, 1)`` means only unigrams, ``(1, 2)`` means unigrams and bigrams, and ``(2, 2)`` means only bigrams. Only applies if ``analyzer is not callable``."
        }
      },
      {
        "name": "analyzer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "analyzer"
          ],
          "default": "analyzer__str",
          "description": "Whether the feature should be made of word or character n-grams. Option 'char_wb' creates character n-grams only from text inside word boundaries; n-grams at the edges of words are padded with space.  If a callable is passed it is used to extract the sequence of features out of the raw, unprocessed input.  .. versionchanged:: 0.21  Since v0.21, if ``input`` is ``filename`` or ``file``, the data is first read from the file and then passed to the given callable analyzer."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "analyzer__str",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "values": [
                "word",
                "char",
                "char_wb"
              ],
              "_structural_type": "str",
              "default": "word"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "analyzer__Callable",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "_structural_type": "Callable"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "n_features",
        "init_args": {
          "semantic_types": [
            "n_features"
          ],
          "_structural_type": "int",
          "default": 1048576,
          "description": "The number of features (columns) in the output matrices. Small numbers of features are likely to cause hash collisions, but large numbers will cause larger coefficient dimensions in linear learners."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "binary",
        "init_args": {
          "semantic_types": [
            "binary"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If True, all non zero counts are set to 1. This is useful for discrete probabilistic models that model binary events rather than integer counts."
        }
      },
      {
        "type": "Enumeration",
        "name": "norm",
        "init_args": {
          "semantic_types": [
            "norm"
          ],
          "values": [
            "l1",
            "l2"
          ],
          "_structural_type": "str",
          "default": "l2",
          "description": "Norm used to normalize term vectors. None for no normalization."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "alternate_sign",
        "init_args": {
          "semantic_types": [
            "alternate_sign"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "When True, an alternating sign is added to the features as to approximately conserve the inner product in the hashed space even for small n_features. This approach is similar to sparse random projection.  .. versionadded:: 0.19"
        }
      }
    ],
    "Params": []
  },
  "PatchExtractor": {
    "name": "sklearn.feature_extraction.image.PatchExtractor",
    "common_name": "PatchExtractor",
    "description": "Extracts patches from a collection of images Read more in the :ref:`User Guide <image_feature_extraction>`.  .. versionadded:: 0.9",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "patch_size",
        "init_args": {
          "semantic_types": [
            "patch_size"
          ],
          "_structural_type": "tuple",
          "default": "None",
          "description": "The dimensions of one patch."
        }
      },
      {
        "name": "max_patches",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_patches"
          ],
          "default": "max_patches__None",
          "description": "The maximum number of patches per image to extract. If max_patches is a float in (0, 1), it is taken to mean a proportion of the total number of patches."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "max_patches__int",
            "init_args": {
              "semantic_types": [
                "max_patches"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "max_patches__float",
            "init_args": {
              "semantic_types": [
                "max_patches"
              ],
              "_structural_type": "float"
            }
          },
          {
            "type": "Constant",
            "name": "max_patches__None",
            "init_args": {
              "semantic_types": [
                "max_patches"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "random_state",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "random_state"
          ],
          "default": "random_state__None",
          "description": "Determines the random number generator used for random sampling when `max_patches` is not None. Use an int to make the randomness deterministic. See :term:`Glossary <random_state>`."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "random_state__int",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "random_state__None",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      }
    ],
    "Params": []
  },
  "TfidfTransformer": {
    "name": "sklearn.feature_extraction.text.TfidfTransformer",
    "common_name": "TfidfTransformer",
    "description": "Transform a count matrix to a normalized tf or tf-idf representation Tf means term-frequency while tf-idf means term-frequency times inverse document-frequency. This is a common term weighting scheme in information retrieval, that has also found good use in document classification.  The goal of using tf-idf instead of the raw frequencies of occurrence of a token in a given document is to scale down the impact of tokens that occur very frequently in a given corpus and that are hence empirically less informative than features that occur in a small fraction of the training corpus.  The formula that is used to compute the tf-idf for a term t of a document d in a document set is tf-idf(t, d) = tf(t, d) * idf(t), and the idf is computed as idf(t) = log [ n / df(t) ] + 1 (if ``smooth_idf=False``), where n is the total number of documents in the document set and df(t) is the document frequency of t; the document frequency is the number of documents in the document set that contain the term t. The effect of adding \"1\" to the idf in the equation above is that terms with zero idf, i.e., terms that occur in all documents in a training set, will not be entirely ignored. (Note that the idf formula above differs from the standard textbook notation that defines the idf as idf(t) = log [ n / (df(t) + 1) ]).  If ``smooth_idf=True`` (the default), the constant \"1\" is added to the numerator and denominator of the idf as if an extra document was seen containing every term in the collection exactly once, which prevents zero divisions: idf(t) = log [ (1 + n) / (1 + df(t)) ] + 1.  Furthermore, the formulas used to compute tf and idf depend on parameter settings that correspond to the SMART notation used in IR as follows:  Tf is \"n\" (natural) by default, \"l\" (logarithmic) when ``sublinear_tf=True``. Idf is \"t\" when use_idf is given, \"n\" (none) otherwise. Normalization is \"c\" (cosine) when ``norm='l2'``, \"n\" (none) when ``norm=None``.  Read more in the :ref:`User Guide <text_feature_extraction>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "norm",
        "init_args": {
          "semantic_types": [
            "norm"
          ],
          "values": [
            "l1",
            "l2"
          ],
          "_structural_type": "str",
          "default": "l2",
          "description": "Each output row will have unit norm, either: * 'l2': Sum of squares of vector elements is 1. The cosine similarity between two vectors is their dot product when l2 norm has been applied. * 'l1': Sum of absolute values of vector elements is 1. See :func:`preprocessing.normalize`"
        }
      },
      {
        "type": "Hyperparameter",
        "name": "use_idf",
        "init_args": {
          "semantic_types": [
            "use_idf"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Enable inverse-document-frequency reweighting."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "smooth_idf",
        "init_args": {
          "semantic_types": [
            "smooth_idf"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Smooth idf weights by adding one to document frequencies, as if an extra document was seen containing every term in the collection exactly once. Prevents zero divisions."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "sublinear_tf",
        "init_args": {
          "semantic_types": [
            "sublinear_tf"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Apply sublinear tf scaling, i.e. replace tf with 1 + log(tf)."
        }
      }
    ],
    "Params": [
      {
        "name": "idf_",
        "type": "array of shape (n_features)",
        "description": "The inverse document frequency (IDF) vector; only defined if  ``use_idf`` is True.  .. versionadded:: 0.20"
      }
    ]
  },
  "TfidfVectorizer": {
    "name": "sklearn.feature_extraction.text.TfidfVectorizer",
    "common_name": "TfidfVectorizer",
    "description": "Convert a collection of raw documents to a matrix of TF-IDF features. Equivalent to :class:`CountVectorizer` followed by :class:`TfidfTransformer`.  Read more in the :ref:`User Guide <text_feature_extraction>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Enumeration",
        "name": "input",
        "init_args": {
          "semantic_types": [
            "input"
          ],
          "values": [
            "filename",
            "file",
            "content"
          ],
          "_structural_type": "str",
          "default": "content",
          "description": "If 'filename', the sequence passed as an argument to fit is expected to be a list of filenames that need reading to fetch the raw content to analyze.  If 'file', the sequence items must have a 'read' method (file-like object) that is called to fetch the bytes in memory.  Otherwise the input is expected to be a sequence of items that can be of type string or byte."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "encoding",
        "init_args": {
          "semantic_types": [
            "encoding"
          ],
          "_structural_type": "str",
          "default": "utf-8",
          "description": "If bytes or files are given to analyze, this encoding is used to decode."
        }
      },
      {
        "type": "Enumeration",
        "name": "decode_error",
        "init_args": {
          "semantic_types": [
            "decode_error"
          ],
          "values": [
            "strict",
            "ignore",
            "replace"
          ],
          "_structural_type": "str",
          "default": "strict",
          "description": "Instruction on what to do if a byte sequence is given to analyze that contains characters not of the given `encoding`. By default, it is 'strict', meaning that a UnicodeDecodeError will be raised. Other values are 'ignore' and 'replace'."
        }
      },
      {
        "type": "Enumeration",
        "name": "strip_accents",
        "init_args": {
          "semantic_types": [
            "strip_accents"
          ],
          "values": [
            "ascii",
            "unicode"
          ],
          "_structural_type": "str",
          "default": "None",
          "description": "Remove accents and perform other character normalization during the preprocessing step. 'ascii' is a fast method that only works on characters that have an direct ASCII mapping. 'unicode' is a slightly slower method that works on any characters. None (default) does nothing.  Both 'ascii' and 'unicode' use NFKD normalization from :func:`unicodedata.normalize`."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "lowercase",
        "init_args": {
          "semantic_types": [
            "lowercase"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Convert all characters to lowercase before tokenizing."
        }
      },
      {
        "name": "preprocessor",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "preprocessor"
          ],
          "default": "preprocessor__None",
          "description": "Override the preprocessing (string transformation) stage while preserving the tokenizing and n-grams generation steps. Only applies if ``analyzer is not callable``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "preprocessor__Callable",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "preprocessor__None",
            "init_args": {
              "semantic_types": [
                "preprocessor"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "tokenizer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "tokenizer"
          ],
          "default": "tokenizer__None",
          "description": "Override the string tokenization step while preserving the preprocessing and n-grams generation steps. Only applies if ``analyzer == 'word'``."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "tokenizer__Callable",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "tokenizer__None",
            "init_args": {
              "semantic_types": [
                "tokenizer"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "analyzer",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "analyzer"
          ],
          "default": "analyzer__str",
          "description": "Whether the feature should be made of word or character n-grams. Option 'char_wb' creates character n-grams only from text inside word boundaries; n-grams at the edges of words are padded with space.  If a callable is passed it is used to extract the sequence of features out of the raw, unprocessed input.  .. versionchanged:: 0.21  Since v0.21, if ``input`` is ``filename`` or ``file``, the data is first read from the file and then passed to the given callable analyzer."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "analyzer__str",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "values": [
                "word",
                "char",
                "char_wb"
              ],
              "_structural_type": "str",
              "default": "word"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "analyzer__Callable",
            "init_args": {
              "semantic_types": [
                "analyzer"
              ],
              "_structural_type": "Callable"
            }
          }
        ]
      },
      {
        "name": "stop_words",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "stop_words"
          ],
          "default": "stop_words__None",
          "description": "If a string, it is passed to _check_stop_list and the appropriate stop list is returned. 'english' is currently the only supported string value. There are several known issues with 'english' and you should consider an alternative (see :ref:`stop_words`).  If a list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens. Only applies if ``analyzer == 'word'``.  If None, no stop words will be used. max_df can be set to a value in the range [0.7, 1.0) to automatically detect and filter stop words based on intra corpus document frequency of terms."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "stop_words__str",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "stop_words__list",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "list"
            }
          },
          {
            "type": "Constant",
            "name": "stop_words__None",
            "init_args": {
              "semantic_types": [
                "stop_words"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "token_pattern",
        "init_args": {
          "semantic_types": [
            "token_pattern"
          ],
          "_structural_type": "str",
          "default": "(?u)\\b\\w\\w+\\b",
          "description": "Regular expression denoting what constitutes a \"token\", only used if ``analyzer == 'word'``. The default regexp selects tokens of 2 or more alphanumeric characters (punctuation is completely ignored and always treated as a token separator).  If there is a capturing group in token_pattern then the captured group content, not the entire match, becomes the token. At most one capturing group is permitted."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "ngram_range",
        "init_args": {
          "semantic_types": [
            "ngram_range"
          ],
          "_structural_type": "tuple",
          "default": "&esc(1, 1)",
          "description": "The lower and upper boundary of the range of n-values for different n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ``ngram_range`` of ``(1, 1)`` means only unigrams, ``(1, 2)`` means unigrams and bigrams, and ``(2, 2)`` means only bigrams. Only applies if ``analyzer is not callable``."
        }
      },
      {
        "name": "max_df",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_df"
          ],
          "default": "max_df__float",
          "description": "When building the vocabulary ignore terms that have a document frequency strictly higher than the given threshold (corpus-specific stop words). If float in range [0.0, 1.0], the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "max_df__float",
            "init_args": {
              "semantic_types": [
                "max_df"
              ],
              "_structural_type": "float",
              "default": 1.0
            }
          },
          {
            "type": "Hyperparameter",
            "name": "max_df__int",
            "init_args": {
              "semantic_types": [
                "max_df"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "name": "min_df",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "min_df"
          ],
          "default": "min_df__int",
          "description": "When building the vocabulary ignore terms that have a document frequency strictly lower than the given threshold. This value is also called cut-off in the literature. If float in range of [0.0, 1.0], the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "min_df__float",
            "init_args": {
              "semantic_types": [
                "min_df"
              ],
              "_structural_type": "float"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "min_df__int",
            "init_args": {
              "semantic_types": [
                "min_df"
              ],
              "_structural_type": "int",
              "default": 1
            }
          }
        ]
      },
      {
        "name": "max_features",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_features"
          ],
          "default": "max_features__None",
          "description": "If not None, build a vocabulary that only consider the top max_features ordered by term frequency across the corpus.  This parameter is ignored if vocabulary is not None."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "max_features__int",
            "init_args": {
              "semantic_types": [
                "max_features"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "max_features__None",
            "init_args": {
              "semantic_types": [
                "max_features"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "vocabulary",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "vocabulary"
          ],
          "default": "vocabulary__None",
          "description": "Either a Mapping (e.g., a dict) where keys are terms and values are indices in the feature matrix, or an iterable over terms. If not given, a vocabulary is determined from the input documents."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "vocabulary__None",
            "init_args": {
              "semantic_types": [
                "vocabulary"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "binary",
        "init_args": {
          "semantic_types": [
            "binary"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If True, all non-zero term counts are set to 1. This does not mean outputs will have only 0/1 values, only that the tf term in tf-idf is binary. (Set idf and normalization to False to get 0/1 outputs)."
        }
      },
      {
        "type": "Enumeration",
        "name": "norm",
        "init_args": {
          "semantic_types": [
            "norm"
          ],
          "values": [
            "l1",
            "l2"
          ],
          "_structural_type": "str",
          "default": "l2",
          "description": "Each output row will have unit norm, either: * 'l2': Sum of squares of vector elements is 1. The cosine similarity between two vectors is their dot product when l2 norm has been applied. * 'l1': Sum of absolute values of vector elements is 1. See :func:`preprocessing.normalize`."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "use_idf",
        "init_args": {
          "semantic_types": [
            "use_idf"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Enable inverse-document-frequency reweighting."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "smooth_idf",
        "init_args": {
          "semantic_types": [
            "smooth_idf"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "Smooth idf weights by adding one to document frequencies, as if an extra document was seen containing every term in the collection exactly once. Prevents zero divisions."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "sublinear_tf",
        "init_args": {
          "semantic_types": [
            "sublinear_tf"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "Apply sublinear tf scaling, i.e. replace tf with 1 + log(tf)."
        }
      }
    ],
    "Params": [
      {
        "name": "vocabulary_",
        "type": "dict",
        "description": "A mapping of terms to feature indices."
      },
      {
        "name": "fixed_vocabulary_: bool",
        "type": "",
        "description": "True if a fixed vocabulary of term to indices mapping is provided by the user"
      },
      {
        "name": "idf_",
        "type": "array of shape (n_features,)",
        "description": "The inverse document frequency (IDF) vector; only defined if ``use_idf`` is True."
      },
      {
        "name": "stop_words_",
        "type": "set",
        "description": "Terms that were ignored because they either:    - occurred in too many documents (`max_df`)   - occurred in too few documents (`min_df`)   - were cut off by feature selection (`max_features`).  This is only available if no vocabulary was given."
      }
    ]
  }
}