{
  "GridSearchCV": {
    "name": "sklearn.model_selection._search.GridSearchCV",
    "common_name": "GridSearchCV",
    "description": "Exhaustive search over specified parameter values for an estimator. Important members are fit, predict.  GridSearchCV implements a \"fit\" and a \"score\" method. It also implements \"score_samples\", \"predict\", \"predict_proba\", \"decision_function\", \"transform\" and \"inverse_transform\" if they are implemented in the estimator used.  The parameters of the estimator used to apply these methods are optimized by cross-validated grid-search over a parameter grid.  Read more in the :ref:`User Guide <grid_search>`.",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "scoring",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "scoring"
          ],
          "default": "scoring__None",
          "description": "A single str (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set.  For evaluating multiple metrics, either give a list of (unique) strings or a dict with names as keys and callables as values.  NOTE that when using custom scorers, each scorer should return a single value. Metric functions returning a list/array of values can be wrapped into multiple scorers that return one value each.  See :ref:`multimetric_grid_search` for an example.  If None, the estimator's score method is used."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "scoring__str",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__Callable",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__list",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "list"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__tuple",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "tuple"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__dict",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "dict"
            }
          },
          {
            "type": "Constant",
            "name": "scoring__None",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "n_jobs",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_jobs"
          ],
          "default": "n_jobs__None",
          "description": "Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.  .. versionchanged:: v0.20    `n_jobs` default changed from 1 to None"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "n_jobs__int",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "n_jobs__None",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "refit",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "refit"
          ],
          "default": "refit__bool",
          "description": "Refit an estimator using the best found parameters on the whole dataset.  For multiple metric evaluation, this needs to be a `str` denoting the scorer that would be used to find the best parameters for refitting the estimator at the end.  Where there are considerations other than maximum score in choosing a best estimator, ``refit`` can be set to a function which returns the selected ``best_index_`` given ``cv_results_``. In that case, the ``best_estimator_`` and ``best_params_`` will be set according to the returned ``best_index_`` while the ``best_score_`` attribute will not be available.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``GridSearchCV`` instance.  Also for multiple metric evaluation, the attributes ``best_index_``, ``best_score_`` and ``best_params_`` will only be available if ``refit`` is set and all of them will be determined w.r.t this specific scorer.  See ``scoring`` parameter to know more about multiple metric evaluation.  .. versionchanged:: 0.20     Support for callable added."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "refit__bool",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "bool",
              "default": "True"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "refit__str",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "refit__Callable",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "Callable"
            }
          }
        ]
      },
      {
        "name": "cv",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "cv"
          ],
          "default": "cv__None",
          "description": "Determines the cross-validation splitting strategy. Possible inputs for cv are:  - None, to use the default 5-fold cross validation, - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. versionchanged:: 0.22     ``cv`` default value if None changed from 3-fold to 5-fold."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "cv__int",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "cv__None",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "verbose",
        "init_args": {
          "semantic_types": [
            "verbose"
          ],
          "_structural_type": "int",
          "default": 0,
          "description": "Controls the verbosity: the higher, the more messages.  - >1 : the computation time for each fold and parameter candidate is   displayed; - >2 : the score is also displayed; - >3 : the fold and candidate parameter indexes are also displayed   together with the starting time of the computation."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "pre_dispatch",
        "init_args": {
          "semantic_types": [
            "pre_dispatch"
          ],
          "_structural_type": "str",
          "default": "2*n_jobs",
          "description": "Controls the number of jobs that get dispatched during parallel execution. Reducing this number can be useful to avoid an explosion of memory consumption when more jobs get dispatched than CPUs can process. This parameter can be:      - None, in which case all the jobs are immediately       created and spawned. Use this for lightweight and       fast-running jobs, to avoid delays due to on-demand       spawning of the jobs      - An int, giving the exact number of total jobs that are       spawned      - A str, giving an expression as a function of n_jobs,       as in '2*n_jobs'"
        }
      },
      {
        "name": "error_score",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "error_score"
          ],
          "default": "error_score__float",
          "description": "Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "error_score__str",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "error_score__float",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "float",
              "default": NaN
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "return_train_score",
        "init_args": {
          "semantic_types": [
            "return_train_score"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance.  .. versionadded:: 0.19  .. versionchanged:: 0.21     Default value was changed from ``True`` to ``False``"
        }
      }
    ],
    "Params": []
  },
  "HalvingGridSearchCV": {
    "name": "sklearn.model_selection._search_successive_halving.HalvingGridSearchCV",
    "common_name": "HalvingGridSearchCV",
    "description": "Search over specified parameter values with successive halving. The search strategy starts evaluating all the candidates with a small amount of resources and iteratively selects the best candidates, using more and more resources.  Read more in the :ref:`User guide <successive_halving_user_guide>`.  .. note::    This estimator is still **experimental** for now: the predictions   and the API might change without any deprecation cycle. To use it,   you need to explicitly import ``enable_halving_search_cv``::      >>> # explicitly require this experimental feature     >>> from sklearn.experimental import enable_halving_search_cv # noqa     >>> # now you can import normally from model_selection     >>> from sklearn.model_selection import HalvingGridSearchCV",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "factor",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "factor"
          ],
          "default": "factor__int",
          "description": "The 'halving' parameter, which determines the proportion of candidates that are selected for each subsequent iteration. For example, ``factor=3`` means that only one third of the candidates are selected."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "factor__int",
            "init_args": {
              "semantic_types": [
                "factor"
              ],
              "_structural_type": "int",
              "default": 3
            }
          },
          {
            "type": "Hyperparameter",
            "name": "factor__float",
            "init_args": {
              "semantic_types": [
                "factor"
              ],
              "_structural_type": "float"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "resource",
        "init_args": {
          "semantic_types": [
            "resource"
          ],
          "_structural_type": "str",
          "default": "n_samples",
          "description": "Defines the resource that increases with each iteration. By default, the resource is the number of samples. It can also be set to any parameter of the base estimator that accepts positive integer values, e.g. 'n_iterations' or 'n_estimators' for a gradient boosting estimator. In this case ``max_resources`` cannot be 'auto' and must be set explicitly."
        }
      },
      {
        "name": "max_resources",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_resources"
          ],
          "default": "max_resources__str",
          "description": "The maximum amount of resource that any candidate is allowed to use for a given iteration. By default, this is set to ``n_samples`` when ``resource='n_samples'`` (default), else an error is raised."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "max_resources__str",
            "init_args": {
              "semantic_types": [
                "max_resources"
              ],
              "_structural_type": "str",
              "default": "auto"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "max_resources__int",
            "init_args": {
              "semantic_types": [
                "max_resources"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "name": "min_resources",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "min_resources"
          ],
          "default": "min_resources__str",
          "description": "The minimum amount of resource that any candidate is allowed to use for a given iteration. Equivalently, this defines the amount of resources `r0` that are allocated for each candidate at the first iteration.  - 'smallest' is a heuristic that sets `r0` to a small value:     - ``n_splits * 2`` when ``resource='n_samples'`` for a regression        problem     - ``n_classes * n_splits * 2`` when ``resource='n_samples'`` for a        classification problem     - ``1`` when ``resource != 'n_samples'`` - 'exhaust' will set `r0` such that the **last** iteration uses as   much resources as possible. Namely, the last iteration will use the   highest value smaller than ``max_resources`` that is a multiple of   both ``min_resources`` and ``factor``. In general, using 'exhaust'   leads to a more accurate estimator, but is slightly more time   consuming.  Note that the amount of resources used at each iteration is always a multiple of ``min_resources``."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "min_resources__str",
            "init_args": {
              "semantic_types": [
                "min_resources"
              ],
              "values": [
                "exhaust",
                "smallest"
              ],
              "_structural_type": "str",
              "default": "exhaust"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "min_resources__int",
            "init_args": {
              "semantic_types": [
                "min_resources"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "aggressive_elimination",
        "init_args": {
          "semantic_types": [
            "aggressive_elimination"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "This is only relevant in cases where there isn't enough resources to reduce the remaining candidates to at most `factor` after the last iteration. If ``True``, then the search process will 'replay' the first iteration for as long as needed until the number of candidates is small enough. This is ``False`` by default, which means that the last iteration may evaluate more than ``factor`` candidates. See :ref:`aggressive_elimination` for more details."
        }
      },
      {
        "name": "cv",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "cv"
          ],
          "default": "cv__int",
          "description": "Determines the cross-validation splitting strategy. Possible inputs for cv are:  - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. note::     Due to implementation details, the folds produced by `cv` must be     the same across multiple calls to `cv.split()`. For     built-in `scikit-learn` iterators, this can be achieved by     deactivating shuffling (`shuffle=False`), or by setting the     `cv`'s `random_state` parameter to an integer."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "cv__int",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "int",
              "default": 5
            }
          },
          {
            "type": "Constant",
            "name": "cv__None",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "None"
            }
          }
        ]
      },
      {
        "name": "scoring",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "scoring"
          ],
          "default": "scoring__None",
          "description": "A single string (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set. If None, the estimator's score method is used."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "scoring__str",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__Callable",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "scoring__None",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "refit",
        "init_args": {
          "semantic_types": [
            "refit"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, refit an estimator using the best found parameters on the whole dataset.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``GridSearchCV`` instance."
        }
      },
      {
        "name": "error_score",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "error_score"
          ],
          "default": "error_score__float",
          "description": "Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error. Default is ``np.nan``"
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "error_score__str",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "error_score__float",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "float",
              "default": NaN
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "return_train_score",
        "init_args": {
          "semantic_types": [
            "return_train_score"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance."
        }
      },
      {
        "name": "random_state",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "random_state"
          ],
          "default": "random_state__None",
          "description": "Pseudo random number generator state used for subsampling the dataset when `resources != 'n_samples'`. Ignored otherwise. Pass an int for reproducible output across multiple function calls. See :term:`Glossary <random_state>`."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "random_state__int",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "random_state__None",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "n_jobs",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_jobs"
          ],
          "default": "n_jobs__None",
          "description": "Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "n_jobs__int",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "n_jobs__None",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "verbose",
        "init_args": {
          "semantic_types": [
            "verbose"
          ],
          "_structural_type": "int",
          "default": 0,
          "description": "Controls the verbosity: the higher, the more messages."
        }
      }
    ],
    "Params": []
  },
  "HalvingRandomSearchCV": {
    "name": "sklearn.model_selection._search_successive_halving.HalvingRandomSearchCV",
    "common_name": "HalvingRandomSearchCV",
    "description": "Randomized search on hyper parameters. The search strategy starts evaluating all the candidates with a small amount of resources and iteratively selects the best candidates, using more and more resources.  The candidates are sampled at random from the parameter space and the number of sampled candidates is determined by ``n_candidates``.  Read more in the :ref:`User guide<successive_halving_user_guide>`.  .. note::    This estimator is still **experimental** for now: the predictions   and the API might change without any deprecation cycle. To use it,   you need to explicitly import ``enable_halving_search_cv``::      >>> # explicitly require this experimental feature     >>> from sklearn.experimental import enable_halving_search_cv # noqa     >>> # now you can import normally from model_selection     >>> from sklearn.model_selection import HalvingRandomSearchCV",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "name": "n_candidates",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_candidates"
          ],
          "default": "n_candidates__str",
          "description": "The number of candidate parameters to sample, at the first iteration. Using 'exhaust' will sample enough candidates so that the last iteration uses as many resources as possible, based on `min_resources`, `max_resources` and `factor`. In this case, `min_resources` cannot be 'exhaust'."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "n_candidates__str",
            "init_args": {
              "semantic_types": [
                "n_candidates"
              ],
              "_structural_type": "str",
              "default": "exhaust"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "n_candidates__int",
            "init_args": {
              "semantic_types": [
                "n_candidates"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "name": "factor",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "factor"
          ],
          "default": "factor__int",
          "description": "The 'halving' parameter, which determines the proportion of candidates that are selected for each subsequent iteration. For example, ``factor=3`` means that only one third of the candidates are selected."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "factor__int",
            "init_args": {
              "semantic_types": [
                "factor"
              ],
              "_structural_type": "int",
              "default": 3
            }
          },
          {
            "type": "Hyperparameter",
            "name": "factor__float",
            "init_args": {
              "semantic_types": [
                "factor"
              ],
              "_structural_type": "float"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "resource",
        "init_args": {
          "semantic_types": [
            "resource"
          ],
          "_structural_type": "str",
          "default": "n_samples",
          "description": "Defines the resource that increases with each iteration. By default, the resource is the number of samples. It can also be set to any parameter of the base estimator that accepts positive integer values, e.g. 'n_iterations' or 'n_estimators' for a gradient boosting estimator. In this case ``max_resources`` cannot be 'auto' and must be set explicitly."
        }
      },
      {
        "name": "max_resources",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "max_resources"
          ],
          "default": "max_resources__str",
          "description": "The maximum number of resources that any candidate is allowed to use for a given iteration. By default, this is set ``n_samples`` when ``resource='n_samples'`` (default), else an error is raised."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "max_resources__str",
            "init_args": {
              "semantic_types": [
                "max_resources"
              ],
              "_structural_type": "str",
              "default": "auto"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "max_resources__int",
            "init_args": {
              "semantic_types": [
                "max_resources"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "name": "min_resources",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "min_resources"
          ],
          "default": "min_resources__str",
          "description": "The minimum amount of resource that any candidate is allowed to use for a given iteration. Equivalently, this defines the amount of resources `r0` that are allocated for each candidate at the first iteration.  - 'smallest' is a heuristic that sets `r0` to a small value:     - ``n_splits * 2`` when ``resource='n_samples'`` for a regression        problem     - ``n_classes * n_splits * 2`` when ``resource='n_samples'`` for a        classification problem     - ``1`` when ``resource != 'n_samples'`` - 'exhaust' will set `r0` such that the **last** iteration uses as   much resources as possible. Namely, the last iteration will use the   highest value smaller than ``max_resources`` that is a multiple of   both ``min_resources`` and ``factor``. In general, using 'exhaust'   leads to a more accurate estimator, but is slightly more time   consuming. 'exhaust' isn't available when `n_candidates='exhaust'`.  Note that the amount of resources used at each iteration is always a multiple of ``min_resources``."
        },
        "hyperparams": [
          {
            "type": "Enumeration",
            "name": "min_resources__str",
            "init_args": {
              "semantic_types": [
                "min_resources"
              ],
              "values": [
                "exhaust",
                "smallest"
              ],
              "_structural_type": "str",
              "default": "smallest"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "min_resources__int",
            "init_args": {
              "semantic_types": [
                "min_resources"
              ],
              "_structural_type": "int"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "aggressive_elimination",
        "init_args": {
          "semantic_types": [
            "aggressive_elimination"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "This is only relevant in cases where there isn't enough resources to reduce the remaining candidates to at most `factor` after the last iteration. If ``True``, then the search process will 'replay' the first iteration for as long as needed until the number of candidates is small enough. This is ``False`` by default, which means that the last iteration may evaluate more than ``factor`` candidates. See :ref:`aggressive_elimination` for more details."
        }
      },
      {
        "name": "cv",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "cv"
          ],
          "default": "cv__int",
          "description": "Determines the cross-validation splitting strategy. Possible inputs for cv are:  - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. note::     Due to implementation details, the folds produced by `cv` must be     the same across multiple calls to `cv.split()`. For     built-in `scikit-learn` iterators, this can be achieved by     deactivating shuffling (`shuffle=False`), or by setting the     `cv`'s `random_state` parameter to an integer."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "cv__int",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "int",
              "default": 5
            }
          },
          {
            "type": "Constant",
            "name": "cv__None",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "None"
            }
          }
        ]
      },
      {
        "name": "scoring",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "scoring"
          ],
          "default": "scoring__None",
          "description": "A single string (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set. If None, the estimator's score method is used."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "scoring__str",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__Callable",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Constant",
            "name": "scoring__None",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "refit",
        "init_args": {
          "semantic_types": [
            "refit"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If True, refit an estimator using the best found parameters on the whole dataset.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``GridSearchCV`` instance."
        }
      },
      {
        "name": "error_score",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "error_score"
          ],
          "default": "error_score__float",
          "description": "Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error. Default is ``np.nan``"
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "error_score__str",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "error_score__float",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "float",
              "default": NaN
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "return_train_score",
        "init_args": {
          "semantic_types": [
            "return_train_score"
          ],
          "_structural_type": "bool",
          "default": "True",
          "description": "If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance."
        }
      },
      {
        "name": "random_state",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "random_state"
          ],
          "default": "random_state__None",
          "description": "Pseudo random number generator state used for subsampling the dataset when `resources != 'n_samples'`. Also used for random uniform sampling from lists of possible values instead of scipy.stats distributions. Pass an int for reproducible output across multiple function calls. See :term:`Glossary <random_state>`."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "random_state__int",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "random_state__None",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "n_jobs",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_jobs"
          ],
          "default": "n_jobs__None",
          "description": "Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "n_jobs__int",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "n_jobs__None",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "verbose",
        "init_args": {
          "semantic_types": [
            "verbose"
          ],
          "_structural_type": "int",
          "default": 0,
          "description": "Controls the verbosity: the higher, the more messages."
        }
      }
    ],
    "Params": []
  },
  "RandomizedSearchCV": {
    "name": "sklearn.model_selection._search.RandomizedSearchCV",
    "common_name": "RandomizedSearchCV",
    "description": "Randomized search on hyper parameters. RandomizedSearchCV implements a \"fit\" and a \"score\" method. It also implements \"score_samples\", \"predict\", \"predict_proba\", \"decision_function\", \"transform\" and \"inverse_transform\" if they are implemented in the estimator used.  The parameters of the estimator used to apply these methods are optimized by cross-validated search over parameter settings.  In contrast to GridSearchCV, not all parameter values are tried out, but rather a fixed number of parameter settings is sampled from the specified distributions. The number of parameter settings that are tried is given by n_iter.  If all parameters are presented as a list, sampling without replacement is performed. If at least one parameter is given as a distribution, sampling with replacement is used. It is highly recommended to use continuous distributions for continuous parameters.  Read more in the :ref:`User Guide <randomized_parameter_search>`.  .. versionadded:: 0.14",
    "sklearn_version": "0.24.0",
    "Hyperparams": [
      {
        "type": "Hyperparameter",
        "name": "n_iter",
        "init_args": {
          "semantic_types": [
            "n_iter"
          ],
          "_structural_type": "int",
          "default": 10,
          "description": "Number of parameter settings that are sampled. n_iter trades off runtime vs quality of the solution."
        }
      },
      {
        "name": "scoring",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "scoring"
          ],
          "default": "scoring__None",
          "description": "A single str (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set.  For evaluating multiple metrics, either give a list of (unique) strings or a dict with names as keys and callables as values.  NOTE that when using custom scorers, each scorer should return a single value. Metric functions returning a list/array of values can be wrapped into multiple scorers that return one value each.  See :ref:`multimetric_grid_search` for an example.  If None, the estimator's score method is used."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "scoring__str",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__Callable",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "Callable"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__list",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "list"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__tuple",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "tuple"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "scoring__dict",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "dict"
            }
          },
          {
            "type": "Constant",
            "name": "scoring__None",
            "init_args": {
              "semantic_types": [
                "scoring"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "n_jobs",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "n_jobs"
          ],
          "default": "n_jobs__None",
          "description": "Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.  .. versionchanged:: v0.20    `n_jobs` default changed from 1 to None"
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "n_jobs__int",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "n_jobs__None",
            "init_args": {
              "semantic_types": [
                "n_jobs"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "refit",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "refit"
          ],
          "default": "refit__bool",
          "description": "Refit an estimator using the best found parameters on the whole dataset.  For multiple metric evaluation, this needs to be a `str` denoting the scorer that would be used to find the best parameters for refitting the estimator at the end.  Where there are considerations other than maximum score in choosing a best estimator, ``refit`` can be set to a function which returns the selected ``best_index_`` given the ``cv_results``. In that case, the ``best_estimator_`` and ``best_params_`` will be set according to the returned ``best_index_`` while the ``best_score_`` attribute will not be available.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``RandomizedSearchCV`` instance.  Also for multiple metric evaluation, the attributes ``best_index_``, ``best_score_`` and ``best_params_`` will only be available if ``refit`` is set and all of them will be determined w.r.t this specific scorer.  See ``scoring`` parameter to know more about multiple metric evaluation.  .. versionchanged:: 0.20     Support for callable added."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "refit__bool",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "bool",
              "default": "True"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "refit__str",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "refit__Callable",
            "init_args": {
              "semantic_types": [
                "refit"
              ],
              "_structural_type": "Callable"
            }
          }
        ]
      },
      {
        "name": "cv",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "cv"
          ],
          "default": "cv__None",
          "description": "Determines the cross-validation splitting strategy. Possible inputs for cv are:  - None, to use the default 5-fold cross validation, - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. versionchanged:: 0.22     ``cv`` default value if None changed from 3-fold to 5-fold."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "cv__int",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "cv__None",
            "init_args": {
              "semantic_types": [
                "cv"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "verbose",
        "init_args": {
          "semantic_types": [
            "verbose"
          ],
          "_structural_type": "int",
          "default": 0,
          "description": "Controls the verbosity: the higher, the more messages."
        }
      },
      {
        "type": "Hyperparameter",
        "name": "pre_dispatch",
        "init_args": {
          "semantic_types": [
            "pre_dispatch"
          ],
          "_structural_type": "str",
          "default": "2*n_jobs",
          "description": "Controls the number of jobs that get dispatched during parallel execution. Reducing this number can be useful to avoid an explosion of memory consumption when more jobs get dispatched than CPUs can process. This parameter can be:      - None, in which case all the jobs are immediately       created and spawned. Use this for lightweight and       fast-running jobs, to avoid delays due to on-demand       spawning of the jobs      - An int, giving the exact number of total jobs that are       spawned      - A str, giving an expression as a function of n_jobs,       as in '2*n_jobs'"
        }
      },
      {
        "name": "random_state",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "random_state"
          ],
          "default": "random_state__None",
          "description": "Pseudo random number generator state used for random uniform sampling from lists of possible values instead of scipy.stats distributions. Pass an int for reproducible output across multiple function calls. See :term:`Glossary <random_state>`."
        },
        "hyperparams": [
          {
            "type": "Hyperparameter",
            "name": "random_state__int",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "int"
            }
          },
          {
            "type": "Constant",
            "name": "random_state__None",
            "init_args": {
              "semantic_types": [
                "random_state"
              ],
              "_structural_type": "None",
              "default": "None"
            }
          }
        ]
      },
      {
        "name": "error_score",
        "type": "Union",
        "init_args": {
          "semantic_types": [
            "error_score"
          ],
          "default": "error_score__float",
          "description": "Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error."
        },
        "hyperparams": [
          {
            "type": "Constant",
            "name": "error_score__str",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "str"
            }
          },
          {
            "type": "Hyperparameter",
            "name": "error_score__float",
            "init_args": {
              "semantic_types": [
                "error_score"
              ],
              "_structural_type": "float",
              "default": NaN
            }
          }
        ]
      },
      {
        "type": "Hyperparameter",
        "name": "return_train_score",
        "init_args": {
          "semantic_types": [
            "return_train_score"
          ],
          "_structural_type": "bool",
          "default": "False",
          "description": "If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance.  .. versionadded:: 0.19  .. versionchanged:: 0.21     Default value was changed from ``True`` to ``False``"
        }
      }
    ],
    "Params": []
  }
}